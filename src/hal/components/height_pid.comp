component height_pid "PID height control";
//" vim
description
"""

The \\fBheight_pid\\fR hal component implements a state machine
and PID (Proportional, Integral, Derivative) controller for
managing the external offset for a single axis.  A candidate
application is torch-height-control for a plasma cutter.

The component receives a \\fBcommand\\fR input representing a
requested torch voltage and a \\fBfeedback\\fR input representing
the measured torch voltage.  A conventional PID computation uses
inputs \\fBpgain\\fR, \\fBigain\\fR, and \\fBdgain\\fR to
generate an external offset control presented as an s32
\\fBkcounts\\fR pin.

Three enabling inputs \\fBenable-in-a\\fR, \\fBenable-in-a\\fR,
and \\fBenable-in-a\\fR are anded internally to enable
offset computation.

A number of pins require mandatory connections as listed
in the pin descriptions.

Scaling is controlled by a single input pin
\\fBk\\fR; a reciprocal output is available at the
\\fBkreciprocal\\fR pin.  The default value for \\fBk\\fR
should be suitable for most configurations.


\\fBEXAMPLE:\\fR
An example simulation configuration is provided at:
\\fBconfigs/sim/axis/external_offsets/hpid.ini\\fR.
""";

//" quote char for vim highlighting

pin  in   bit active      = 0     "From: motion.eoffset-active";
pin  in   bit is_on       = 0     "From: halui.machine.is-on";

pin  in   bit enable_in_a = 0     "Enable Input a";
pin  in   bit enable_in_b = 0     "Enable Input b";
pin  in   bit enable_in_c = 0     "Enable Input c";

pin  in float command     = 0     "Command Input";
pin  in float feedback    = 0     "Feedback Input";

pin  in float pgain       = 1     "Proportional gain";
pin  in float igain       = 0     "Integral gain";
pin  in float dgain       = 0     "Derivative gain";

pin  in   s32 fnum        = 0     "Function selector (default 0 == PID)";
pin  in   u32 k           = 10000 "Scaling Factor (if 0, use 10000)";

pin out   bit enable_out  "To: axis.L.eoffset-enable";
pin out   bit clear       "To: axis.L.eoffset-clear";
pin out   s32 kcounts     "To: axis.L.eoffset-counts";
pin out float kreciprocal "To: axis.L.eoffset-scale (1/k)";

pin out float offset_dbg  "offset (debug pin--use kcounts & kreciprocal)";
pin out   u32 state_dbg   "state  (debug pin)";
pin out float error       "following error (debug pin)";

function _;
license "GPL";
;;

#include <rtapi_math.h>

#define FINISH_DELAY 0
#define TO_RAD       M_PI/180

static int    run_ct   = 0;
static int    delay_ct = 0;


static double periodrecip;
static double the_period;

struct ofunc_data {
  double  p_gain;
  double  i_gain;
  double  d_gain;
  double  cmd;
  double  fb;
  double  prev_cmd;
  double  prev_fb;

  //persistent items:
  double* err;
  double* err_d;
  double* err_i;
  double* ovalue;
};

typedef int ofunc(struct ofunc_data);
static      ofunc func0;

typedef enum {
    OFF,
    READY,
    RUNNING,
    STOPPING,
    FINISH,
} state;

#define HPID_DEBUG
#undef  HPID_DEBUG
#ifdef  HPID_DEBUG
  #define LVL RTAPI_MSG_INFO
  #define dprint(msg,n) do { \
     rtapi_set_msg_level(LVL); \
     rtapi_print_msg(LVL,"%20s %5d\n",msg,n); \
  } while (0)
#else
  #define dprint(msg,n)
#endif

FUNCTION(_) {
    static struct ofunc_data data;
    static int    do_once  = 1;
    static state  thestate = OFF;
    static int    messaged = 0;
    static int    err_stop = 0;

    // items computed in thefunc:
    static double err;
    static double err_i;
    static double err_d;
    static double ovalue;

    int    kfactor;
    int    enable_in;
    ofunc* thefunc;

    if (do_once) {
       the_period   = period * 1e-9;
       periodrecip  = 1/the_period;
       err          = 0;
       err_i        = 0;
       err_d        = 0;
       data.err     = &err;
       data.err_i   = &err_i;
       data.err_d   = &err_d;
       data.ovalue  = &ovalue;
       do_once      = 0;
    }

    run_ct++;
    state_dbg = thestate;
    if (k == 0) {kfactor = 10000;}
    kreciprocal = 1/((float)kfactor);

    if (!is_on) {
        // note: the external_offsets implementation defines
        //       axis.L.eoffset as zero when machine is off
        err_stop   = 0;
        enable_out = 0;
        kcounts    = 0; offset_dbg = 0; 
        messaged   = 0;
        thestate   = OFF;
        return;
    }

    
    enable_in = enable_in_a && enable_in_b && enable_in_c;

    switch (thestate) {
    case OFF:
        // require an enable_in 0-->1 transition to advance to READY
        if (enable_in) {
            if (!messaged) {
                rtapi_print_msg(RTAPI_MSG_ERR,
                "height_pid: active enable-in not honored at start");
                messaged = 1;
            }
            return;
        }
        messaged = 1;
        kcounts  = 0;
        thestate = READY;
        dprint("OFF->READY",kcounts);
        return;
        break;
    case READY:
        if (!enable_in) {return;}
        kcounts    = 0; offset_dbg = 0;
        enable_out = 0;
        delay_ct   = 0;
        thestate   = RUNNING;
        dprint("READY->RUNNING",kcounts);
        return;
        break;
    case RUNNING:
        if (enable_in) {
            enable_out = 1;
            thestate   = RUNNING;
        } else {
            /* 
            ** When the enable_in pin is deasserted, kcounts are set to
            ** zero and the simple trajectory planner removes the offset to
            ** within its stopping criterion.  Under some conditions, a
            ** residual offset may remain.  Connecting the clear pin to
            ** axis.L.eoffset-clear forces the axis->ext_offset_tp.pos_cmd
            ** to zero to remove any residual with no modifications to
            ** simple_tp.c
            */
            clear    = 1;
            kcounts  = 0; offset_dbg = 0;
            thestate = STOPPING;
            delay_ct = run_ct;
            dprint("RUNNING->STOPPING",kcounts);
            return;
        }
        break;
    case STOPPING:
        if (active) {
            thestate = STOPPING;
        } else {
            // !active ==> stopping criterion met
            delay_ct = run_ct;
            thestate = FINISH;
            dprint("STOPPING->FINISH",kcounts);
        }
        return;
        break;
    case FINISH:
        // provision for delay if needed
        if (run_ct < (FINISH_DELAY + delay_ct) ) {
            thestate   = FINISH;
        } else {
            enable_out = 0;
            if (err_stop) {
                thestate = OFF;
                dprint("FINISH->OFF",kcounts);
            } else {
                thestate = READY;
                dprint("FINISH->READY",kcounts);
            }
        }
        clear = 0;
        return;
        break;
    } //switch (thestate)

    switch (fnum) {
      case  0: thefunc = func0; break;
      default: thefunc = func0; break;
    }
    // current hal pin values:
    data.d_gain  = dgain;
    data.p_gain  = pgain;
    data.i_gain  = igain;
    data.cmd     = command;
    data.fb      = feedback;

    // calculations:
    if (thefunc(data) ) {
        // thefunc returned nonzero (problem)
        err_stop       = 1;
        *(data.ovalue) = 0;
        kcounts        = 0; offset_dbg = 0;
        thestate       = STOPPING;
        rtapi_print_msg(RTAPI_MSG_ERR,
           "height_pid stopping:func%d problem\n",fnum);
        return;
    }

    // items for next iteration:
    data.prev_cmd = command;
    data.prev_fb  = feedback;

    // results:
    kcounts    = kfactor * *(data.ovalue); // offset counts
    offset_dbg = kcounts * kreciprocal;    // debug pin
    error      = *data.err;                // debug pin
}

static int func0 (struct ofunc_data d)
{
    // PID
    if (   (d.p_gain < 0)
        || (d.i_gain < 0)
        || (d.d_gain < 0) ) {
        rtapi_print_msg(RTAPI_MSG_ERR,
           "height_pid stopping: negative gain\n");
    }
    *d.err       = d.cmd - d.fb;
    *d.err_d     = ( (d.cmd - d.fb) - (d.prev_cmd  - d.prev_fb) )
                 * periodrecip;
    *d.err_i    += *d.err   * the_period;
    *d.ovalue    = d.p_gain * *d.err
                 + d.i_gain * *d.err_i
                 + d.d_gain * *d.err_d;
    return 0;
}
